# 二分查找知识总结

二分查找是一种针对有序数组的高效查找算法，基本思想是将查找区间不断缩小一半，以此快速定位目标元素。

例如在猜数字游戏中，给定1 - 100之间的整数让你猜，每次猜区间中间点数字，若中间点大于目标数字，下次猜前半部分中间点；若小于，则猜后半部分中间点，不断缩小范围来找到目标。

## 代码实现

### 查找最左边匹配项



```
int findFirstOccurrence(const vector\<int>& nums, int target) {

&#x20;   int l = 0, r = nums.size() - 1;

&#x20;   int first = -1;

&#x20;   while (l <= r) {

&#x20;       int mid = l + (r - l) / 2;

&#x20;       if (nums\[mid] == target) {

&#x20;           first = mid;

&#x20;           r = mid - 1;

&#x20;       } else if (nums\[mid] < target) {

&#x20;           l = mid + 1;

&#x20;       } else {

&#x20;           r = mid - 1;

&#x20;       }

&#x20;   }

&#x20;   return first;

}
```

此函数初始化左右指针`l`和`r`，循环计算中间位置`mid`。若`nums[mid]`等于目标值，记录位置并左移右指针继续找更左位置；若小于目标值，右移左指针；若大于，左移右指针。

### 查找最右边匹配项



```
int findLastOccurrence(const vector\<int>& nums, int target) {

&#x20;   int l = 0, r = nums.size() - 1;

&#x20;   int last = -1;

&#x20;   while (l <= r) {

&#x20;       int mid = l + (r - l) / 2;

&#x20;       if (nums\[mid] == target) {

&#x20;           last = mid;

&#x20;           l = mid + 1;

&#x20;       } else if (nums\[mid] < target) {

&#x20;           l = mid + 1;

&#x20;       } else {

&#x20;           r = mid - 1;

&#x20;       }

&#x20;   }

&#x20;   return last;

}
```

与查找最左边匹配项类似，找到目标值时记录位置并右移左指针找更右位置。

在`main`函数中，通过输入数组长度、元素以及查询个数和查询元素，调用上述两个函数可输出每个查询元素在数组中的起始和终止位置。

## 二分法严格定义

对于在区间\[a,b]上连续不断且满足f(a)\*f(b)<0的函数y=f(x)，通过不断地把函数f(x)的零点所在区间二等分，使区间两个端点逐步逼近零点，进而得到零点近似值的方法，与二分查找思想一致，都是缩小区间逼近目标。

## 边界条件处理

**左右边界更新**：在查找数组中某个值最后出现的位置时，若用常规方式更新左右边界，如计算`mid = (l + r) / 2` ，后续有`l = mid`操作，当区间只有两个元素（`r = l + 1` ）时，会因整数除法向下取整导致`mid = l` ，更新`l = mid`后`l`值不变，陷入死循环。

解决办法：若程序中有`l = mid` ，`mid`的值用`(l + r + 1) / 2`计算；若有`r = mid` ，`mid`的值用`(l + r) / 2`计算，确保每次更新边界后区间能有效缩小。

**停止二分**：当`l<r`成立时进行二分，`l = r`时停止。停止后判断区间内唯一元素是否为答案，完成算法。






链表知识总结
链表是一种与数组不同的数据结构，通过指针将节点串联。
链表节点定义
链表节点结构体包含数据域val和指针域next，用于指向下一个节点。
struct LinkedNode {
    int val;
    LinkedNode* next;
    LinkedNode(int val):val(val), next(nullptr){}
};

链表操作函数
初始化：引入虚拟头节点_dummyHead，不存储实际数据，简化链表操作，同时用_size记录链表长度。
MyLinkedList() {
    _dummyHead = new LinkedNode(0);
    _size = 0;
}

获取节点值：get(index)函数先检查index合法性，若超出范围或为负则返回 - 1，再遍历链表获取第index个节点的值。
int get(int index) {
    if (index > (_size - 1) || index < 0) {
        return -1;
    }
    LinkedNode* cur = _dummyHead->next;
    while(index--){
        cur = cur->next;
    }
    return cur->val;
}

头部添加节点：addAtHead(val)函数创建新节点，使其指向原头节点，再更新虚拟头节点的下一个节点为新节点，链表长度加 1。
void addAtHead(int val) {
    LinkedNode* newNode = new LinkedNode(val);
    newNode->next = _dummyHead->next;
    _dummyHead->next = newNode;
    _size++;
}

尾部添加节点：addAtTail(val)函数遍历链表找到最后一个节点（next为nullptr），将新节点添加其后，链表长度加 1。
void addAtTail(int val) {
    LinkedNode* newNode = new LinkedNode(val);
    LinkedNode* cur = _dummyHead;
    while(cur->next!= nullptr){
        cur = cur->next;
    }
    cur->next = newNode;
    _size++;
}

指定位置添加节点：addAtIndex(index, val)函数根据index决定插入位置。index大于链表长度不插入；小于 0 则在头部插入；等于链表长度在尾部插入；其他情况遍历到第index个节点之前插入，链表长度加 1。
void addAtIndex(int index, int val) {
    if(index > _size) return;
    if(index < 0) index = 0;
    LinkedNode* newNode = new LinkedNode(val);
    LinkedNode* cur = _dummyHead;
    while(index--) {
        cur = cur->next;
    }
    newNode->next = cur->next;
    cur->next = newNode;
    _size++;
}

删除指定位置节点：deleteAtIndex(index)函数先检查index合法性，合法则遍历到第index个节点之前，移除该节点并释放内存，将指向该节点的指针置为nullptr，链表长度减 1。
void deleteAtIndex(int index) {
    if (index >= _size || index < 0) {
        return;
    }
    LinkedNode* cur = _dummyHead;
    while(index--) {
        cur = cur ->next;
    }
    LinkedNode* tmp = cur->next;
    cur->next = cur->next->next;
    delete tmp;
    tmp=nullptr;
    _size--;
}

边界条件与内存管理
链表操作需严格检查边界条件，如index合法性，避免越界。删除节点时要释放内存并将指针置nullptr，防止野指针。

